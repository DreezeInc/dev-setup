---
- name: Developer Environment Setup - GitHub Repository + Development Tools (macOS Apple Silicon)
  hosts: localhost
  connection: local
  gather_facts: false
  become: no  # Default to no privilege escalation
  vars:
    repo_url: "https://github.com/DreezeInc/dreeze-git-0.git"
    dest_path: "~/code/dreeze"
    repo_version: "main"  # Use master for octocat repository, or specify branch/tag/commit hash
    ansible_become_method: sudo
    ansible_become_user: root
  
  tasks:
    - name: Check if Xcode Command Line Tools are installed
      shell: xcode-select -p
      register: xcode_check
      failed_when: false
      changed_when: false
    
    - name: Install Xcode Command Line Tools if not present
      shell: xcode-select --install
      when: xcode_check.rc != 0
      register: xcode_install
    
    - name: Wait for Xcode Command Line Tools installation (if triggered)
      pause:
        prompt: "Please complete the Xcode Command Line Tools installation in the popup dialog, then press Enter to continue"
      when: xcode_check.rc != 0 and xcode_install.rc == 0
    
    - name: Verify git is available
      shell: which git
      register: git_check
      failed_when: git_check.rc != 0
      changed_when: false
    
    - name: Check if GitHub CLI (gh) is installed
      shell: which gh
      register: gh_check_early
      failed_when: false
      changed_when: false
    
    - name: Install GitHub CLI (gh) via Homebrew (for git authentication)
      homebrew:
        name: gh
        state: present
      when: gh_check_early.rc != 0
      register: gh_install_early
    
    - name: Check GitHub authentication status
      shell: gh auth status
      register: gh_auth_status
      failed_when: false
      changed_when: false
    
    - name: Run GitHub authentication script
      shell: bash ./github_auth.sh
      when: gh_auth_status.rc != 0
      register: gh_auth_result
    
    - name: Verify GitHub authentication after login
      shell: gh auth status
      register: gh_auth_verify
      when: gh_auth_result is defined and gh_auth_result.changed
      failed_when: false
    
    - name: Display authentication result
      debug:
        msg: |
          {% if gh_auth_verify is defined and gh_auth_verify.rc is defined and gh_auth_verify.rc == 0 %}
          âœ… GitHub authentication successful! You can now access private repositories.
          {% elif gh_auth_verify is defined and gh_auth_verify.rc is defined and gh_auth_verify.rc != 0 %}
          âš ï¸  GitHub authentication not completed. Public repositories will still work.
          ðŸ’¡ You can authenticate later by running: ./github_auth.sh
          {% elif gh_auth_result is defined %}
          âœ… GitHub authentication process completed.
          {% else %}
          âœ… GitHub authentication was already configured.
          {% endif %}
      when: gh_auth_result is defined or gh_auth_verify is defined or gh_auth_status.rc != 0
    
    - name: Setup git to use GitHub CLI credentials
      shell: gh auth setup-git
      register: git_setup_result
      when: >
        (gh_auth_status.rc == 0) or 
        (gh_auth_verify is defined and gh_auth_verify.rc == 0)
      failed_when: false
      changed_when: git_setup_result.rc is defined and git_setup_result.rc == 0
    
    - name: Display git credential setup result
      debug:
        msg: "âœ… Git configured to use GitHub CLI credentials"
      when: git_setup_result is defined and git_setup_result.rc is defined and git_setup_result.rc == 0
    
    - name: Check if Homebrew is installed
      shell: which brew
      register: brew_check
      failed_when: false
      changed_when: false
    
    - name: Install Homebrew if not present
      shell: NONINTERACTIVE=1 /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
      when: brew_check.rc != 0
      register: homebrew_install
      # become: yes  # Homebrew should NOT be installed with sudo
    
    - name: Add Homebrew to PATH for Apple Silicon
      shell: eval "$(/opt/homebrew/bin/brew shellenv)"
      when: brew_check.rc != 0 and homebrew_install is defined
      changed_when: false
    
    - name: Update Homebrew (idempotent)
      homebrew:
        update_homebrew: yes
      when: brew_check.rc == 0 or homebrew_install is defined
    
    - name: Check if Slack is installed
      shell: ls /Applications/Slack.app
      register: slack_check
      failed_when: false
      changed_when: false

    - name: Check if Google Chrome is installed
      shell: ls /Applications/Google\ Chrome.app
      register: chrome_check
      failed_when: false
      changed_when: false
    
    - name: Install Slack via Homebrew Cask
      homebrew_cask:
        name: slack
        state: present
      when: slack_check.rc != 0
      register: slack_install
      # become: yes  # Not required for Homebrew Cask on modern macOS

    - name: Install Google Chrome via Homebrew Cask
      homebrew_cask:
        name: google-chrome
        state: present
      when: chrome_check.rc != 0
      register: chrome_install
      # become: yes  # Not required for Homebrew Cask on modern macOS
    
    - name: Check if Cursor is installed
      shell: ls /Applications/Cursor.app
      register: cursor_check
      failed_when: false
      changed_when: false
    
    - name: Install Cursor via Homebrew Cask
      homebrew_cask:
        name: cursor
        state: present
      when: cursor_check.rc != 0
      register: cursor_install
      # become: yes  # Not required for Homebrew Cask on modern macOS

    - name: Launch Cursor once to set up CLI
      shell: open -a Cursor
      when: cursor_install is defined and cursor_install.changed
      async: 0
      poll: 0

    - name: Wait for Cursor initialization
      pause:
        seconds: 10
      when: cursor_install is defined and cursor_install.changed

    - name: Quit Cursor after initialization
      shell: osascript -e 'quit app "Cursor"'
      when: cursor_install is defined and cursor_install.changed
      ignore_errors: true

    - name: Check if cursor CLI is available
      shell: which cursor
      register: cursor_cli_check
      failed_when: false
      changed_when: false

    - name: Symlink Cursor CLI if missing
      shell: |
        CURSOR_APP="/Applications/Cursor.app"
        for p in "$CURSOR_APP/Contents/Resources/app/bin/cursor" \
                 "$CURSOR_APP/Contents/MacOS/cursor"; do
          if [ -x "$p" ]; then
            TARGET="$p"
            break
          fi
        done
        if [ -n "$TARGET" ]; then
          if [ -d /opt/homebrew/bin ]; then
            ln -sf "$TARGET" /opt/homebrew/bin/cursor
          else
            ln -sf "$TARGET" /usr/local/bin/cursor
          fi
        fi
      when: cursor_cli_check.rc != 0
      become: yes

    - name: Re-check cursor CLI availability
      shell: which cursor
      register: cursor_cli_final
      failed_when: false
      changed_when: false
    
    - name: Check if GitLens extension is installed in Cursor
      shell: cursor --list-extensions 2>/dev/null | grep -i "eamodio.gitlens"
      register: gitlens_check
      failed_when: false
      changed_when: false
      when: cursor_cli_final.rc == 0
    
    - name: Install GitLens extension in Cursor
      shell: cursor --install-extension eamodio.gitlens --force
      when: gitlens_check.rc != 0 and cursor_cli_final.rc == 0
      register: gitlens_install
      ignore_errors: yes
    
    - name: Check if Python extension is installed in Cursor
      shell: cursor --list-extensions 2>/dev/null | grep -i "ms-python.python"
      register: python_ext_check
      failed_when: false
      changed_when: false
      when: cursor_cli_final.rc == 0
    
    - name: Install Python extension in Cursor
      shell: cursor --install-extension ms-python.python --force
      when: python_ext_check.rc != 0 and cursor_cli_final.rc == 0
      register: python_ext_install
      ignore_errors: yes
    
    - name: Check if Python Debugger extension is installed in Cursor
      shell: cursor --list-extensions 2>/dev/null | grep -i "ms-python.debugpy"
      register: python_debugger_check
      failed_when: false
      changed_when: false
      when: cursor_cli_final.rc == 0
    
    - name: Install Python Debugger extension in Cursor
      shell: cursor --install-extension ms-python.debugpy --force
      when: python_debugger_check.rc != 0 and cursor_cli_final.rc == 0
      register: python_debugger_install
      ignore_errors: yes
    
    - name: Check if jq is installed (needed for Docker Desktop Kubernetes setup)
      shell: which jq
      register: jq_check
      failed_when: false
      changed_when: false
    
    - name: Install jq via Homebrew (required for Kubernetes enablement)
      homebrew:
        name: jq
        state: present
      when: jq_check.rc != 0
    
    - name: Check if Docker is installed
      shell: ls /Applications/Docker.app
      register: docker_check
      failed_when: false
      changed_when: false
    
    - name: Install Docker Desktop via Homebrew Cask
      homebrew_cask:
        name: docker
        state: present
      when: docker_check.rc != 0
      register: docker_install
      # become: yes  # Not required for Homebrew Cask on modern macOS
    
    - name: Check if Docker Desktop is running
      shell: pgrep -f "Docker Desktop" || docker info >/dev/null 2>&1
      register: docker_running_check
      failed_when: false
      changed_when: false
    
    - name: Start Docker Desktop if not running
      shell: open -a Docker
      when: docker_running_check.rc != 0
      register: docker_start
      ignore_errors: yes
    
    - name: Check if Docker was already installed but not running
      set_fact:
        docker_needs_startup: "{{ docker_check.rc == 0 and docker_running_check.rc != 0 }}"
    
    - name: Display Docker startup message
      debug:
        msg: "ðŸ³ Docker Desktop was already installed but not running. Starting Docker..."
      when: docker_needs_startup | bool
    
    - name: Wait for Docker Desktop to start initially
      pause:
        seconds: 15
      when: docker_start is defined and docker_start.changed
    
    - name: Ensure Docker is ready after starting
      shell: |
        echo "Waiting for Docker to start..."
        for i in {1..30}; do
          if docker info >/dev/null 2>&1; then
            echo "Docker is ready!"
            exit 0
          fi
          echo "Waiting for Docker... ($i/30)"
          sleep 3
        done
        echo "Docker failed to start within 90 seconds"
        exit 1
      when: docker_start is defined and docker_start.changed
      register: docker_startup_ready
      ignore_errors: yes
    
    - name: Check which Docker Desktop settings file exists
      shell: |
        if [ -f "$HOME/Library/Group Containers/group.com.docker/settings-store.json" ]; then
          echo "settings-store.json"
        elif [ -f "$HOME/Library/Group Containers/group.com.docker/settings.json" ]; then
          echo "settings.json"
        else
          echo "none"
        fi
      register: settings_file_type
      changed_when: false
    
    - name: Check if Kubernetes is enabled in Docker Desktop
      shell: |
        if [ "{{ settings_file_type.stdout }}" == "settings-store.json" ]; then
          DOCKER_SETTINGS="$HOME/Library/Group Containers/group.com.docker/settings-store.json"
          if [ -f "$DOCKER_SETTINGS" ]; then
            cat "$DOCKER_SETTINGS" | jq -r '.kubernetes // false'
          else
            echo "false"
          fi
        elif [ "{{ settings_file_type.stdout }}" == "settings.json" ]; then
          DOCKER_SETTINGS="$HOME/Library/Group Containers/group.com.docker/settings.json"
          if [ -f "$DOCKER_SETTINGS" ]; then
            if cat "$DOCKER_SETTINGS" | grep -q '"kubernetesEnabled":true'; then
              echo "true"
            else
              echo "false"
            fi
          else
            echo "false"
          fi
        else
          echo "false"
        fi
      register: k8s_enabled_check
      failed_when: false
      changed_when: false
    
    - name: Wait for Docker Desktop settings file to be created
      shell: |
        for i in {1..20}; do
          if [ -f "$HOME/Library/Group Containers/group.com.docker/settings-store.json" ] || [ -f "$HOME/Library/Group Containers/group.com.docker/settings.json" ]; then
            echo "Docker Desktop settings file found"
            exit 0
          fi
          echo "Waiting for Docker Desktop settings file... ($i/20)"
          sleep 3
        done
        echo "Docker Desktop settings file not found after waiting"
        exit 1
      when: k8s_enabled_check is defined and k8s_enabled_check.stdout is defined and k8s_enabled_check.stdout == "false" and settings_file_type is defined and settings_file_type.stdout is defined and settings_file_type.stdout == "none"
      register: settings_file_wait
      ignore_errors: yes
    
    - name: Re-check which settings file exists after waiting
      shell: |
        if [ -f "$HOME/Library/Group Containers/group.com.docker/settings-store.json" ]; then
          echo "settings-store.json"
        elif [ -f "$HOME/Library/Group Containers/group.com.docker/settings.json" ]; then
          echo "settings.json"
        else
          echo "none"
        fi
      when: k8s_enabled_check is defined and k8s_enabled_check.stdout is defined and k8s_enabled_check.stdout == "false" and settings_file_wait is defined
      register: settings_file_type_after_wait
      changed_when: false
    
    - name: Determine final settings file type
      set_fact:
        final_settings_type: "{{ settings_file_type_after_wait.stdout if settings_file_type_after_wait is defined and settings_file_type_after_wait.stdout is defined else (settings_file_type.stdout if settings_file_type is defined and settings_file_type.stdout is defined else 'none') }}"    
    - name: Enable containerd image store (required for newer Docker Desktop Kubernetes)
      shell: |
        RESTART_NEEDED=false
        if [ "{{ final_settings_type }}" == "settings-store.json" ]; then
          DOCKER_SETTINGS="$HOME/Library/Group Containers/group.com.docker/settings-store.json"
          if [ -f "$DOCKER_SETTINGS" ]; then
            # Check if containerd is already enabled
            CONTAINERD_ENABLED=$(cat "$DOCKER_SETTINGS" | jq -r '.containerdEnabled // false')
            if [ "$CONTAINERD_ENABLED" != "true" ]; then
              echo "Enabling containerd image store..."
              cat "$DOCKER_SETTINGS" | jq '.containerdEnabled = true' > "$DOCKER_SETTINGS.tmp" && mv "$DOCKER_SETTINGS.tmp" "$DOCKER_SETTINGS"
              echo "containerd image store enabled - Docker Desktop restart required"
              RESTART_NEEDED=true
            else
              echo "containerd image store already enabled"
            fi
          fi
        elif [ "{{ final_settings_type }}" == "settings.json" ]; then
          DOCKER_SETTINGS="$HOME/Library/Group Containers/group.com.docker/settings.json"
          if [ -f "$DOCKER_SETTINGS" ]; then
            # Check if containerd is already enabled
            if ! cat "$DOCKER_SETTINGS" | grep -q '"useContainerdSnapshotter":true'; then
              echo "Enabling containerd image store..."
              cat "$DOCKER_SETTINGS" | jq '.useContainerdSnapshotter = true' > "$DOCKER_SETTINGS.tmp" && mv "$DOCKER_SETTINGS.tmp" "$DOCKER_SETTINGS"
              echo "containerd image store enabled - Docker Desktop restart required"
              RESTART_NEEDED=true
            else
              echo "containerd image store already enabled"
            fi
          fi
        fi
        echo "RESTART_NEEDED=$RESTART_NEEDED"
      register: containerd_enable
      ignore_errors: yes
      changed_when: containerd_enable.stdout is search("RESTART_NEEDED=true")
    
    - name: Enable Kubernetes in Docker Desktop settings
      shell: |
        if [ "{{ final_settings_type }}" == "settings-store.json" ]; then
          DOCKER_SETTINGS="$HOME/Library/Group Containers/group.com.docker/settings-store.json"
          if [ -f "$DOCKER_SETTINGS" ]; then
            # Create backup
            cp "$DOCKER_SETTINGS" "$DOCKER_SETTINGS.backup"
            # Enable Kubernetes with the new settings format
            cat "$DOCKER_SETTINGS" | jq '.kubernetes = true' > "$DOCKER_SETTINGS.tmp" && mv "$DOCKER_SETTINGS.tmp" "$DOCKER_SETTINGS"
            echo "Kubernetes enabled in Docker Desktop settings-store.json"
          else
            echo "ERROR: Docker Desktop settings-store.json not found"
            exit 1
          fi
        elif [ "{{ final_settings_type }}" == "settings.json" ]; then
          DOCKER_SETTINGS="$HOME/Library/Group Containers/group.com.docker/settings.json"
          if [ -f "$DOCKER_SETTINGS" ]; then
            # Create backup
            cp "$DOCKER_SETTINGS" "$DOCKER_SETTINGS.backup"
            # Enable Kubernetes with the old settings format
            cat "$DOCKER_SETTINGS" | jq '.kubernetesEnabled = true' > "$DOCKER_SETTINGS.tmp" && mv "$DOCKER_SETTINGS.tmp" "$DOCKER_SETTINGS"
            echo "Kubernetes enabled in Docker Desktop settings.json"
          else
            echo "ERROR: Docker Desktop settings.json not found"
            exit 1
          fi
        else
          echo "ERROR: No Docker Desktop settings file found"
          exit 1
        fi
      when: k8s_enabled_check is defined and k8s_enabled_check.stdout is defined and k8s_enabled_check.stdout == "false"
      register: k8s_enable
      ignore_errors: yes
    
    - name: Check if manual Docker restart is needed
      debug:
        msg: |
          âš ï¸  Docker Desktop needs to be restarted to apply settings changes.
          
          The playbook will attempt to restart Docker Desktop automatically.
          If this causes issues, you can:
          1. Press Ctrl+C to stop the playbook
          2. Manually restart Docker Desktop
          3. Re-run the playbook with: SKIP_DOCKER_RESTART=1 ansible-playbook playbook.yml
      when: (k8s_enable is defined and k8s_enable.changed) or (containerd_enable is defined and containerd_enable.changed)
    
    - name: Restart Docker Desktop to apply settings changes
      shell: |
        echo "Restarting Docker Desktop..."
        osascript -e 'quit app "Docker Desktop"'
        sleep 10
        open -a Docker
        echo "Docker Desktop restart initiated"
      when: ((k8s_enable is defined and k8s_enable.changed) or (containerd_enable is defined and containerd_enable.changed)) and (lookup('env', 'SKIP_DOCKER_RESTART') != '1')
      register: docker_restart
      ignore_errors: yes
    
    - name: Wait for Docker Desktop app to fully launch
      pause:
        seconds: 20
        prompt: "Waiting for Docker Desktop to initialize..."
      when: docker_restart is defined and docker_restart.changed
    
    - name: Wait for Docker daemon to be ready
      shell: |
        echo "Waiting for Docker daemon to be ready..."
        MAX_ATTEMPTS=40
        ATTEMPT=0
        while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
          ATTEMPT=$((ATTEMPT + 1))
          
          # Check if Docker Desktop is running
          if ! pgrep -f "Docker Desktop" > /dev/null; then
            echo "Docker Desktop not running, waiting... ($ATTEMPT/$MAX_ATTEMPTS)"
            sleep 5
            continue
          fi
          
          # Check if docker daemon is responding
          if docker version --format '{{ "{{.Server.Version}}" }}' 2>/dev/null; then
            echo "Docker daemon is ready!"
            exit 0
          fi
          
          # Try alternative check
          if docker ps >/dev/null 2>&1; then
            echo "Docker daemon is ready!"
            exit 0
          fi
          
          echo "Waiting for Docker daemon... ($ATTEMPT/$MAX_ATTEMPTS)"
          sleep 5
        done
        
        echo "Docker daemon took longer than expected"
        echo "You may need to manually start Docker Desktop"
        exit 0
      when: (k8s_enable is defined and k8s_enable.changed) or (docker_start is defined and docker_start.changed and k8s_enabled_check.stdout == "false") or (containerd_enable is defined and containerd_enable.changed) or (docker_restart is defined and docker_restart.changed)
      register: docker_ready
      ignore_errors: yes
      
    - name: Force Kubernetes initialization with Docker Desktop restart
      shell: |
        echo "Attempting to trigger Kubernetes initialization..."
        # Sometimes Docker Desktop needs multiple restarts to properly initialize Kubernetes
        osascript -e 'quit app "Docker Desktop"' 2>/dev/null || true
        sleep 10
        open -a "Docker Desktop"
        sleep 30
      when: k8s_enable is defined and k8s_enable.changed
      ignore_errors: yes

    - name: Check for kubectl configuration
      stat:
        path: ~/.kube/config
      register: kubeconfig_check
      
    - name: Wait for kubectl configuration to be created
      shell: |
        echo "Waiting for kubectl configuration..."
        for i in {1..30}; do
          if [ -f "$HOME/.kube/config" ]; then
            echo "kubectl configuration found!"
            exit 0
          fi
          echo "Waiting for kubectl configuration... ($i/30)"
          sleep 5
        done
        echo "kubectl configuration not found after waiting"
        exit 1
      when: k8s_enable is defined and k8s_enable.changed and kubeconfig_check is defined and kubeconfig_check.stat is defined and not kubeconfig_check.stat.exists
      register: kubeconfig_wait
      ignore_errors: yes

    - name: Set docker-desktop as default kubectl context
      shell: |
        if kubectl config get-contexts docker-desktop >/dev/null 2>&1; then
          kubectl config use-context docker-desktop
          echo "Set docker-desktop as default context"
        else
          echo "docker-desktop context not found"
          exit 1
        fi
      when: (kubeconfig_wait is defined and kubeconfig_wait is succeeded) or (kubeconfig_check is defined and kubeconfig_check.stat is defined and kubeconfig_check.stat.exists)
      ignore_errors: yes

    - name: Wait for Kubernetes to be ready (optional)
      shell: |
        echo "Waiting for Kubernetes to start..."
        MAX_ATTEMPTS=40
        ATTEMPT=0
        
        while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
          ATTEMPT=$((ATTEMPT + 1))
          
          # Check if kubectl can connect
          if kubectl cluster-info >/dev/null 2>&1; then
            echo "Kubernetes is ready!"
            kubectl get nodes
            exit 0
          fi
          
          # Check if API server is responding on typical ports
          if nc -zv localhost 6443 2>&1 | grep -q succeeded; then
            echo "Kubernetes API server is listening on port 6443"
          elif nc -zv localhost 8080 2>&1 | grep -q succeeded; then
            echo "Kubernetes API server is listening on port 8080"
          fi
          
          echo "Waiting for Kubernetes... ($ATTEMPT/$MAX_ATTEMPTS)"
          sleep 5
        done
        
        echo "Kubernetes took longer than expected, but continuing..."
        echo "You can check Kubernetes status later with: kubectl cluster-info"
        exit 0
      when: k8s_enable is defined and k8s_enable.changed
      register: k8s_ready
      failed_when: false
      ignore_errors: yes

    - name: Pre-pull Kubernetes images for faster startup
      shell: |
        echo "Pre-pulling Kubernetes system images..."
        # These are common images needed by Kubernetes
        docker pull registry.k8s.io/pause:3.9 2>/dev/null || true
        docker pull registry.k8s.io/coredns/coredns:v1.11.1 2>/dev/null || true
        docker pull docker/desktop-storage-provisioner:v2.0 2>/dev/null || true
        docker pull docker/desktop-vpnkit-controller:dc331cb22850be0cdd97c84a9cfecaf44a1afb6e 2>/dev/null || true
        echo "Pre-pulled common Kubernetes images"
      when: k8s_enable is defined and k8s_enable.changed
      ignore_errors: yes
    
    - name: Display Docker and Kubernetes status
      debug:
        msg: |
          ðŸ³ Docker Status: {{ 'Ready' if (docker_ready is defined and docker_ready.stdout is defined and 'Docker is ready' in docker_ready.stdout) or (docker_startup_ready is defined and docker_startup_ready.stdout is defined and 'Docker is ready' in docker_startup_ready.stdout) else 'Starting (check with: docker info)' }}
          Kubernetes Status: {{ 'Ready' if k8s_ready is defined and k8s_ready.stdout is defined and 'Kubernetes is ready' in k8s_ready.stdout else 'Starting (check with: kubectl cluster-info)' }}          {% if docker_ready is defined and docker_ready.stdout is defined and 'longer than expected' in docker_ready.stdout %}
          
          âš ï¸  Docker Desktop is taking longer than expected to start.
          
          Please check:
          1. Open Docker Desktop manually if it's not already open
          2. Check if Docker Desktop is asking for your password
          3. Make sure Docker Desktop has necessary permissions
          4. Wait for the Docker icon in the menu bar to stop animating
          
          Once Docker is running, you can continue with the setup.
          {% endif %}
          {% if k8s_enable is defined and k8s_enable.changed %}
          
          ðŸ’¡ Note: If Kubernetes doesn't start automatically, please:
             1. Open Docker Desktop
             2. Go to Settings â†’ Kubernetes
             3. Check "Enable Kubernetes"
             4. Click "Apply & Restart"
             5. Wait for the "Kubernetes is running" status (this can take 2-5 minutes)
          
          Once Kubernetes is running, verify with:
             kubectl cluster-info
             kubectl get nodes
          
          This manual step may be required on newer Docker Desktop versions.
          {% endif %}
          
          {% if (k8s_ready is defined and k8s_ready.stdout is defined and 'longer than expected' in k8s_ready.stdout) or (kubeconfig_wait is defined and kubeconfig_wait.failed is defined and kubeconfig_wait.failed) %}
          
          âš ï¸  Kubernetes initialization requires manual intervention:
          
          Docker Desktop's Kubernetes feature needs to download and install components
          on first run. This process cannot be fully automated via command line.
          
          Please follow these steps:
          1. Open Docker Desktop manually
          2. Navigate to Settings â†’ Kubernetes
          3. Ensure "Enable Kubernetes" is checked
          4. Click "Apply & Restart"
          5. Wait for the progress bar to complete (usually 2-5 minutes)
          6. Look for "Kubernetes is running" with a green indicator
          
          After manual setup, run the check script to verify:
             ./check-k8s.sh
          {% endif %}
      when: docker_ready is defined or k8s_ready is defined or docker_startup_ready is defined or k8s_enable is defined
    
    - name: Check if pyenv is installed
      shell: which pyenv
      register: pyenv_check
      failed_when: false
      changed_when: false
    
    - name: Check if direnv is installed
      shell: which direnv
      register: direnv_check
      failed_when: false
      changed_when: false
    
    - name: Check if uv is installed
      shell: which uv
      register: uv_check
      failed_when: false
      changed_when: false
    
    - name: Check if make is installed
      shell: which make
      register: make_check
      failed_when: false
      changed_when: false
    
    - name: Install pyenv via Homebrew
      homebrew:
        name: pyenv
        state: present
      when: pyenv_check.rc != 0
    
    - name: Install direnv via Homebrew
      homebrew:
        name: direnv
        state: present
      when: direnv_check.rc != 0
    
    - name: Install uv via Homebrew
      homebrew:
        name: uv
        state: present
      when: uv_check.rc != 0
    
    - name: Install make via Homebrew
      homebrew:
        name: make
        state: present
      when: make_check.rc != 0
    
    - name: Check if helm is installed
      shell: which helm
      register: helm_check
      failed_when: false
      changed_when: false
    
    - name: Check if go-task is installed
      shell: which task
      register: go_task_check
      failed_when: false
      changed_when: false
    
    - name: Check if openapi-generator is installed
      shell: which openapi-generator
      register: openapi_generator_check
      failed_when: false
      changed_when: false
    
    - name: Check if swagger-codegen is installed
      shell: which swagger-codegen
      register: swagger_codegen_check
      failed_when: false
      changed_when: false
    
    - name: Check if k9s is installed
      shell: which k9s
      register: k9s_check
      failed_when: false
      changed_when: false
    

    
    - name: Install helm via Homebrew
      homebrew:
        name: helm
        state: present
      when: helm_check.rc != 0
    
    - name: Install go-task via Homebrew (from go-task tap)
      shell: brew install go-task/tap/go-task
      when: go_task_check.rc != 0
    
    - name: Install openapi-generator via Homebrew
      homebrew:
        name: openapi-generator
        state: present
      when: openapi_generator_check.rc != 0
    
    - name: Install swagger-codegen via Homebrew
      homebrew:
        name: swagger-codegen
        state: present
      when: swagger_codegen_check.rc != 0
    
    - name: Install k9s via Homebrew (from derailed tap)
      shell: brew install derailed/k9s/k9s
      when: k9s_check.rc != 0
    

    
    - name: Get home directory
      shell: echo $HOME
      register: home_dir
      changed_when: false
    
    - name: Check if pyenv shell integration is already configured
      shell: grep -q 'pyenv init' "{{ home_dir.stdout }}/.zshrc"
      register: pyenv_configured
      failed_when: false
      changed_when: false
    
    - name: Ensure .zshrc exists
      file:
        path: "{{ home_dir.stdout }}/.zshrc"
        state: touch
        mode: '0644'
      when: pyenv_check.rc != 0 or pyenv_configured.rc != 0
    
    - name: Setup pyenv shell integration
      lineinfile:
        path: "{{ home_dir.stdout }}/.zshrc"
        line: "{{ item }}"
        create: yes
        insertafter: EOF
      loop:
        - 'export PYENV_ROOT="$HOME/.pyenv"'
        - 'command -v pyenv >/dev/null || export PATH="$PYENV_ROOT/bin:$PATH"'
        - 'eval "$(pyenv init -)"'
      when: pyenv_configured.rc != 0
    
    - name: Check if Python 3.13 is already installed via pyenv
      shell: |
        export PYENV_ROOT="$HOME/.pyenv"
        export PATH="$PYENV_ROOT/bin:$PATH"
        eval "$(pyenv init -)" 2>/dev/null || true
        pyenv versions --bare | grep -q "^3\.13"
      register: python313_check
      failed_when: false
      changed_when: false
      when: pyenv_check.rc == 0
    
    - name: Install Python 3.13 via pyenv
      shell: |
        export PYENV_ROOT="$HOME/.pyenv"
        export PATH="$PYENV_ROOT/bin:$PATH"
        eval "$(pyenv init -)"
        pyenv install --skip-existing 3.13
      when: (pyenv_check.rc != 0 or pyenv_configured.rc != 0) or (python313_check is defined and python313_check.rc != 0)
      register: python_install
      changed_when: "'already exists' not in python_install.stderr"
    
    - name: Check if ruff is installed
      shell: |
        export PYENV_ROOT="$HOME/.pyenv"
        export PATH="$PYENV_ROOT/bin:$PATH"
        eval "$(pyenv init -)" 2>/dev/null || true
        which ruff
      register: ruff_check
      failed_when: false
      changed_when: false
    
    - name: Check if alembic is installed
      shell: |
        export PYENV_ROOT="$HOME/.pyenv"
        export PATH="$PYENV_ROOT/bin:$PATH"
        eval "$(pyenv init -)" 2>/dev/null || true
        which alembic
      register: alembic_check
      failed_when: false
      changed_when: false
    
    - name: Check if pytest is installed
      shell: |
        export PYENV_ROOT="$HOME/.pyenv"
        export PATH="$PYENV_ROOT/bin:$PATH"
        eval "$(pyenv init -)" 2>/dev/null || true
        which pytest
      register: pytest_check
      failed_when: false
      changed_when: false
    
    - name: Check if pytest-cov is installed
      shell: |
        export PYENV_ROOT="$HOME/.pyenv"
        export PATH="$PYENV_ROOT/bin:$PATH"
        eval "$(pyenv init -)" 2>/dev/null || true
        python3 -c "import pytest_cov" 2>/dev/null
      register: pytest_cov_check
      failed_when: false
      changed_when: false
    
    - name: Install ruff via uv
      shell: |
        export PYENV_ROOT="$HOME/.pyenv"
        export PATH="$PYENV_ROOT/bin:$PATH"
        eval "$(pyenv init -)" 2>/dev/null || true
        uv tool install ruff
      when: ruff_check.rc != 0
    
    - name: Install alembic via uv
      shell: |
        export PYENV_ROOT="$HOME/.pyenv"
        export PATH="$PYENV_ROOT/bin:$PATH"
        eval "$(pyenv init -)" 2>/dev/null || true
        uv tool install alembic
      when: alembic_check.rc != 0
    
    - name: Install pytest via uv
      shell: |
        export PYENV_ROOT="$HOME/.pyenv"
        export PATH="$PYENV_ROOT/bin:$PATH"
        eval "$(pyenv init -)" 2>/dev/null || true
        uv tool install pytest
      when: pytest_check.rc != 0
    
    - name: Install pytest-cov via uv (as pytest plugin)
      shell: |
        export PYENV_ROOT="$HOME/.pyenv"
        export PATH="$PYENV_ROOT/bin:$PATH"
        eval "$(pyenv init -)" 2>/dev/null || true
        uv tool install pytest --with pytest-cov
      when: pytest_cov_check.rc != 0
    
    - name: Check if direnv shell integration is already configured
      shell: grep -q 'direnv hook' "{{ home_dir.stdout }}/.zshrc"
      register: direnv_configured
      failed_when: false
      changed_when: false
    
    - name: Setup direnv shell integration
      lineinfile:
        path: "{{ home_dir.stdout }}/.zshrc"
        line: 'eval "$(direnv hook zsh)"'
        create: yes
        insertafter: EOF
      when: direnv_configured.rc != 0
    
    - name: Check if ll alias is already configured
      shell: grep -q "alias ll='ls -la'" "{{ home_dir.stdout }}/.zshrc"
      register: ll_alias_configured
      failed_when: false
      changed_when: false
    
    - name: Setup ll alias
      lineinfile:
        path: "{{ home_dir.stdout }}/.zshrc"
        line: "alias ll='ls -la'"
        create: yes
        insertafter: EOF
      when: ll_alias_configured.rc != 0
    
    - name: Ensure destination directory exists
      file:
        path: "{{ dest_path | expanduser | dirname }}"
        state: directory
        mode: '0755'
    
    - name: Get default branch name from remote repository
      shell: "git ls-remote --symref {{ repo_url }} HEAD | head -n1 | sed 's/ref: refs\\/heads\\///' | sed 's/[[:space:]].*//' "
      register: default_branch
      when: repo_version == "auto"
      failed_when: false
      changed_when: false
    
    - name: Set final branch version
      set_fact:
        final_repo_version: "{{ default_branch.stdout | trim if repo_version == 'auto' and default_branch is defined and default_branch.rc == 0 and default_branch.stdout != '' else repo_version }}"
    
    - name: Check if repository already exists
      stat:
        path: "{{ dest_path | expanduser }}"
      register: repo_exists
    
    - name: Clone repository if it doesn't exist
      git:
        repo: "{{ repo_url }}"
        dest: "{{ dest_path | expanduser }}"
        version: "{{ final_repo_version }}"
        force: false
      when: not repo_exists.stat.exists
      register: git_clone
    
    - name: Update existing repository
      git:
        repo: "{{ repo_url }}"
        dest: "{{ dest_path | expanduser }}"
        version: "{{ final_repo_version }}"
        force: true
      when: repo_exists.stat.exists
      register: git_update
    
    - name: Set git result for display
      set_fact:
        git_result: "{{ git_clone if git_clone is defined else git_update }}"
    
    - name: Display setup summary
      debug:
        msg: |
          ðŸŽ Developer Environment Setup Complete!
          =========================================
          
          âœ… Core Development Tools:
          Xcode Command Line Tools: {{ 'Already installed' if xcode_check is defined and xcode_check.rc == 0 else 'Newly installed' }}
          Homebrew: {{ 'Already installed' if brew_check is defined and brew_check.rc == 0 else 'Newly installed' }}
          Git: {{ 'Available' if git_check is defined and git_check.rc == 0 else 'Not available' }}
          Make: {{ 'Already installed' if make_check is defined and make_check.rc == 0 else 'Newly installed' }}
          
          âœ… Python Development Tools:
          pyenv (Python version manager): {{ 'Already installed' if pyenv_check is defined and pyenv_check.rc == 0 else 'Newly installed' }}
          Python 3.13: {{ 'Already installed' if python313_check is defined and python313_check.rc == 0 else ('Newly installed' if python_install is defined and python_install.changed else 'Installed') }}
          uv (Fast Python package manager): {{ 'Already installed' if uv_check is defined and uv_check.rc == 0 else 'Newly installed' }}
          ruff (Python linter/formatter): {{ 'Already installed' if ruff_check is defined and ruff_check.rc == 0 else 'Newly installed' }}
          pytest (Testing framework): {{ 'Already installed' if pytest_check is defined and pytest_check.rc == 0 else 'Newly installed' }}
          pytest-cov (Test coverage): {{ 'Already installed' if pytest_cov_check is defined and pytest_cov_check.rc == 0 else 'Newly installed' }}
          alembic (Database migrations): {{ 'Already installed' if alembic_check is defined and alembic_check.rc == 0 else 'Newly installed' }}
          
          âœ… DevOps & Infrastructure Tools:
          helm (Kubernetes package manager): {{ 'Already installed' if helm_check is defined and helm_check.rc == 0 else 'Newly installed' }}
          go-task (Task runner): {{ 'Already installed' if go_task_check is defined and go_task_check.rc == 0 else 'Newly installed' }}
          openapi-generator (API tools): {{ 'Already installed' if openapi_generator_check is defined and openapi_generator_check.rc == 0 else 'Newly installed' }}
          swagger-codegen (API code generation): {{ 'Already installed' if swagger_codegen_check is defined and swagger_codegen_check.rc == 0 else 'Newly installed' }}
          k9s (Kubernetes CLI UI): {{ 'Already installed' if k9s_check is defined and k9s_check.rc == 0 else 'Newly installed' }}
          GitHub CLI (gh): {{ 'Already installed' if gh_check_early is defined and gh_check_early.rc == 0 else 'Newly installed' }}
          
          âœ… Environment & Communication:
          direnv (Environment manager): {{ 'Already installed' if direnv_check is defined and direnv_check.rc == 0 else 'Newly installed' }}
          Slack: {{ 'Already installed' if slack_check is defined and slack_check.rc == 0 else 'Newly installed' }}
          Google Chrome: {{ 'Already installed' if chrome_check is defined and chrome_check.rc == 0 else 'Newly installed' }}
          Cursor AI IDE: {{ 'Already installed' if cursor_check is defined and cursor_check.rc == 0 else 'Newly installed' }}
          GitLens Extension (Cursor): {{ 'Already installed' if gitlens_check is defined and gitlens_check.rc == 0 else 'Newly installed' }}
          Python Extension (Cursor): {{ 'Already installed' if python_ext_check is defined and python_ext_check.rc == 0 else 'Newly installed' }}
          Python Debugger Extension (Cursor): {{ 'Already installed' if python_debugger_check is defined and python_debugger_check.rc == 0 else 'Newly installed' }}
          Docker Desktop: {{ 'Already installed' if docker_check is defined and docker_check.rc == 0 else 'Newly installed' }}
          Kubernetes (Docker Desktop): {{ 'Already enabled' if k8s_enabled_check is defined and k8s_enabled_check.rc == 0 else 'Newly enabled' }}
          
          ðŸ“‚ Repository Details:
          Repository: {{ repo_url }}
          Destination: {{ dest_path | expanduser }}
          Branch/Version: {{ final_repo_version }}
          Status: {{ 'Cloned' if git_clone is defined and git_clone.changed else ('Updated' if git_update is defined and git_update.changed else 'Already up to date') }}
          
          ðŸŽ‰ Platform: macOS Apple Silicon
          
          ðŸ’¡ Next Steps:
          â€¢ Restart your terminal or run: source ~/.zshrc
          
          ðŸ“š Tool Usage Examples:
          
          ðŸ Python Development:
          â€¢ pyenv list                        # Show available Python versions
          â€¢ pyenv install 3.12                # Install another Python version
          â€¢ pyenv global 3.13                 # Set Python 3.13 as default
          â€¢ pyenv local 3.12                  # Set Python 3.12 for current project
          â€¢ pyenv versions                    # Show installed Python versions
          
          â€¢ uv venv                           # Create virtual environment (fast!)
          â€¢ uv pip install -r requirements.txt # Install dependencies
          â€¢ uv pip install package==1.2.3     # Install specific package version
          â€¢ uv pip list                       # List installed packages
          â€¢ uv pip freeze > requirements.txt  # Export dependencies
          
          â€¢ ruff check .                      # Lint Python code
          â€¢ ruff check . --fix                # Auto-fix linting issues
          â€¢ ruff format .                     # Format Python code
          â€¢ ruff rule E501                    # Show details about a rule
          
          â€¢ pytest                            # Run all tests
          â€¢ pytest tests/test_module.py       # Run specific test file
          â€¢ pytest -v                         # Verbose test output
          â€¢ pytest --cov                      # Run tests with coverage
          â€¢ pytest --cov=mymodule --cov-report=html  # HTML coverage report
          â€¢ pytest -k "test_name"             # Run tests matching pattern
          â€¢ pytest -x                         # Stop on first failure
          
          â€¢ alembic init migrations           # Initialize migrations
          â€¢ alembic revision -m "Add user table"  # Create new migration
          â€¢ alembic upgrade head              # Apply all migrations
          â€¢ alembic downgrade -1              # Rollback one migration
          â€¢ alembic history                   # Show migration history
          
          ðŸ”§ Environment Management:
          â€¢ echo 'layout python' > .envrc     # Auto-activate Python venv
          â€¢ echo 'export API_KEY=secret' >> .envrc  # Set env variables
          â€¢ direnv allow                      # Approve .envrc file
          â€¢ direnv reload                     # Reload environment
          â€¢ direnv status                     # Check direnv status
          
          ðŸ™ GitHub CLI:
          â€¢ gh auth login                     # Authenticate with GitHub
          â€¢ gh auth status                    # Check authentication
          â€¢ gh repo create my-project --public # Create new repository
          â€¢ gh repo clone owner/repo          # Clone repository
          â€¢ gh repo fork owner/repo --clone   # Fork and clone
          â€¢ gh pr create --title "Fix bug"    # Create pull request
          â€¢ gh pr list                        # List pull requests
          â€¢ gh issue create --title "Bug report" # Create issue
          â€¢ gh workflow run tests.yml         # Trigger GitHub Action
          
          ðŸ—ï¸ Build Tools:
          â€¢ make                              # Run default target
          â€¢ make build                        # Build project
          â€¢ make test                         # Run tests
          â€¢ make clean                        # Clean build artifacts
          â€¢ make help                         # Show available targets
          
          â€¢ task --list                       # List available tasks
          â€¢ task build                        # Run build task
          â€¢ task test                         # Run test task
          â€¢ task --parallel lint test         # Run tasks in parallel
          â€¢ task --watch                      # Watch for changes
          
          ðŸ”„ API Development:
          â€¢ openapi-generator list            # List available generators
          â€¢ openapi-generator generate \
            -i api.yaml \
            -g python-flask \
            -o ./server                       # Generate Flask server
          â€¢ openapi-generator generate \
            -i api.yaml \
            -g typescript-axios \
            -o ./client                       # Generate TypeScript client
          
          â€¢ swagger-codegen generate \
            -i api.yaml \
            -l python \
            -o ./client                       # Generate Python client
          â€¢ swagger-codegen config-help -l python  # Show config options
          
          ðŸ³ Docker & Kubernetes:
          â€¢ docker --version                  # Check Docker version
          â€¢ docker ps                         # List running containers
          â€¢ docker images                     # List images
          â€¢ docker build -t myapp .           # Build image
          â€¢ docker run -p 8080:80 myapp       # Run container
          â€¢ docker compose up                 # Start services
          â€¢ docker compose down               # Stop services
          
          â€¢ kubectl cluster-info              # Check cluster status
          â€¢ kubectl get nodes                 # List cluster nodes
          â€¢ kubectl get pods                  # List pods
          â€¢ kubectl get services              # List services
          â€¢ kubectl apply -f deployment.yaml  # Deploy application
          â€¢ kubectl logs pod-name             # View pod logs
          â€¢ kubectl exec -it pod-name -- bash # Shell into pod
          
          â€¢ helm repo add bitnami https://charts.bitnami.com/bitnami
          â€¢ helm search repo postgres         # Search for charts
          â€¢ helm install mydb bitnami/postgresql  # Install chart
          â€¢ helm list                         # List releases
          â€¢ helm upgrade mydb bitnami/postgresql  # Upgrade release
          â€¢ helm rollback mydb 1              # Rollback to revision
          
          â€¢ k9s                               # Launch K9s UI
          â€¢ :pods                             # View pods in k9s
          â€¢ :svc                              # View services in k9s
          â€¢ :ns                               # Switch namespaces
          â€¢ ctrl-a                            # Show all resources
          â€¢ /pattern                          # Search resources
          
          ðŸ’» IDE (Cursor):
          â€¢ cursor .                          # Open current directory
          â€¢ cursor file.py                    # Open specific file
          â€¢ cursor --list-extensions          # List installed extensions
          â€¢ cursor --install-extension ext-id # Install extension
          â€¢ Cmd+Shift+P                       # Command palette
          â€¢ Cmd+P                             # Quick file open
          
          ðŸš€ Quick Start Workflow:
          1. cd ~/code/my-project
          2. pyenv local 3.13                 # Set Python version
          3. uv venv                          # Create virtual env
          4. echo 'source .venv/bin/activate' > .envrc
          5. direnv allow                     # Auto-activate venv
          6. uv pip install -r requirements.txt
          7. ruff check . --fix && ruff format .
          8. pytest --cov
          9. cursor .                         # Open in IDE
          
          This playbook is idempotent - you can safely re-run it anytime! 